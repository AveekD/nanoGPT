EECS 280: Programming and Introductory Data Structures. This course covers several fundamental concepts in programming.This course, and Computer Science in general, is not about computers, as stated by Hal Abelson. Instead, the purpose of this course is to examine the generalizable concepts in programming. To understand what a generalizable concept is, let’s take a diversion from programming and consider a concept in baking.Summer Stone of The Cake Blog varied the number of eggs in a recipe between zero and four, finding the following. The generalizable concept here is that eggs provide structure to a cake, and that more eggs results in a lighter cake, up to a point.This course will cover the generalizable concepts in programming. We will use C++ as our vehicle for learning these concepts. The course will also implement several large programming projects to develop our experience.Consider a basic machine model where memory is represented as a big array. Each index in the array corresponds to a memory location that can hold a value. For each of the variables declared within main() the value of the variable is stored in some memory location.In source code, a name refers to some entity such as a variable, function, or type. A name has a scope, which determines what region of code can use that name to refer to an entity. A declaration is what introduces a name into the program and begins its scope. Attempting to use y outside this region will result in a compiler error.An object has a lifetime during which it is legal to use that object. The storage duration of an object determines its lifetime. There are three options that we will see in C++: static, automatic and dynamic.An important consideration in the design of a language is the semantics of an initialization or assignment. Does this change which object x is referring to, or does it modify the value of the object that x is refer to? The first option is known as reference semantics, while the second is value semantics.C++ supports reference semantics only when initializing a new variable. Placing an ampersand (&) to the left of the new variable name causes the name to be associated with an existing object.
In stack-based memory management, activation records are stored in a data structure called a stack. A stack works just like a stack of pancakes: when a new pancake is made, it is placed on top of the stack, and when a pancakes is removed from the stack it is the top pancake that is taken off.When an activation record is created, it is placed on top of the stack, and the first activation record to be destroyed is the last one that was created. This gives rise to an equivalent term stack frame for anactivation record. The last pancake to be made is the first to be eaten, resulting in last-in, first-out (LIFO) behavior.In many implementations, the stack is actually stored upside down in memory, so that it grows downward rather than upward as shown in Figure 7. However, it still has the same LIFO behavior as a right-side-up stack.The program then proceeds to call plus_two(result). First, result is evaluated to obtain the value 1. Then an activation record is created for plus_ two() with space for its parameter x. The body of plus_Two() in turn calls plus_one(x + 1).The program creates an activation record for plus_one() and then runs it. The state of memory at this point is shown in Figure 9. Each invocation of a function gets its own activation record. In addition, there are now two variables x in the program.C++ allows references to const to bind to values (i.e. rvalues in programming-language terms) rather than objects (lvalues) So a reference of type const int & can bind to just the value 3, as in constint int &ref = 3;. The order in which arguments are evaluated is unspecified in C++.The body of the called function is run. The activation record is pushed onto the stack. The parameters are passed, using the corresponding arguments toinitial the parameters.The following program is an example of pass by reference. The program starts by creating an activation record for main() with space for the local variables a and b. It initializes a to 3 and b to 7 and then prints out their values. Since the two parameters are references, the activation record does not contain user-accessible memory.The program proceeds to run the body of swap() in a non-programming example. Abstraction is the principle of separating what something is or does from how it does it. It is the primary tool for managing complexity in Computer Science and other fields.In a complex system, there are multiple layers of abstraction. In the case of a sandwich, the top layer is the consumer of the sandwich, who only needs to know that it is a sandwich. The layer below is the sandwich maker, who needs to knows what bread, peanut butter, and jelly are. functions are our mechanism for defining procedural abstractions. The user of a function need only know what the function does without caring about how the function accomplishes its task. In general, we organize a program by decomposing it into independent modules, defined in separate files.The header contains the interface of the module, while the source file contains the actual implementation. As long as the interface remains the same, the implementation of a module can change arbitrarily without affecting the behavior of a source file that uses it.#include pulls in the code from the target into the current file. Library modules such as vector and iostream are surrounded by angle brackets in a #include directive. Non-library headers that are located in the same directory are surrounded with double quotes.It is considered bad practice among C++ programmers to include a using namespace std; directive, or generally other using declarations, in a header file. An alternative is to avoid the prefix for specific entities with individual using declarations. The overall file structure for Project 1 is shown in Figure 12.The command is called g++. The --std=c++11 argument tells it to compile according to the C++11 language standard. The -pedantic argument tells the compiler to adhere strictly to the standard.The linking step can fail if: A function is declared and used in the source files, but no definition is found. Multiple definitions of the same function are found. The return type of a regular (i.e. non-template) function is not part of its signature. It is, however, part of the function’s interface.The documentation format we use in this course is an RME. The RME consists of a REQUIRES clause, a MODIFIES clause, and an EFFECTS clause. The REQUirES clause lists what the function requires in order to accomplish its task. If the requirements are not met, then the function provides no guarantees – the behavior is undefined.A good practice is to assert that the REQUIRES clause is met, if it is possible to do so. If a function doesn’t have any requirements, the RE RequirES clause may be elided. The MODIFIES clause specifies the entities outside the function that might be modified by it. This includes pass-by-reference parameters, global variables (not in this course – only global constants are permitted). The purpose of the MODIFIES clause is for the user to quickly tell what items might be modified. The EFFECTS clause specifies what the function actually does. This includes details about what modifications are made, if any. abstractions are substitutable – we should be able to swap out an implementation of an abstraction for a different one. As long as the interface remains the same, code that uses the abstraction will still work. Abstractions should also be local, meaning that it should be possible to understand the implementation of one abstraction without knowing anything about the implementations of others.Software bugs can lead to disastrous consequences. A radiation-therapy machine from the 1980s was plagued by software bugs. Knight Capital Group, a financial-services firm, was forced to sell itself to a competitor after a software bug caused a huge loss.Testing is the mechanism for determining whether or not code is buggy. Unit tests test once piece of code at a time, often at the granularity of individual functions or small groups of functions. System tests test an entire module or program as a whole.In software development, it is important to maintain a set of regression tests, or tests that are run every time a code change is made. Test-driven development is a common programming practice that integrates writing tests with developing the implementation of a program.Only valid test cases should be written. Those that don’t compile are useless, as well as those that result in undefined behavior. Simple test cases are for the “average” case. Edge cases are those that test special cases in a unit’s behavior.Test cases should focus on cases that realistically could be erroneous. For example, a malicious programmer could insert a bug that only occurs for a specific, arbitrary input. Stress tests will not be used in this course, since the projects we will focus on are not performance-critical.The small scope hypothesis states that thorough testing with “small” test cases is sufficient to catch most bugs in a system 4. In general, our test cases need not be large – in general, they should be small enough where we can compute the expected results.
In C++, an object is a piece of data in memory, and that it is located at some address in memory. The compiler and runtime determine the location of an object when it is created. In many implementations, running the same program twice on the same system will result in different addresses.In C++, the & (usually pronounced “address-of”) operator can be applied to an object to determine its address. Addresses are usually written in hexadecimal (base-16) notation, with a leading 0x followed by digits in the range 0-9 and a-f.A pointer is an object that holds an address as its value. The terms address and pointer are often used interchangeably. A pointer variable can be declared by placing a * symbol to the left of the variable name in its declaration.A pointer object can be dereferenced to obtain the object whose address the pointer is holding by applying the * (usually pronounced “star” or “dereference”) operator. We often say that a pointer “points to” an object, and that the * operator “follows” the pointer to the object it is pointing at.A pointer is an atomic type, since it cannot be subdivided into smaller objects. As with other atomic types, a variable of pointer type that isn’t explicitly initialized is default initialized to an undefined value. Dereferencing a default-initialized pointer results in undefined behavior. Undefined behavior is notoriously difficult to debug.Dereferencing an uninitialized pointer results in undefined behavior. With undefined behavior, anything is possible. Tools like Valgrind or an address sanitizer can help detect this.In C++, the nullptr literal represents the null value. Dereferencing a null pointer also results in undefined behavior. In most implementations, doing so will crash the program.The code above takes the address of an object called a. It then calls print() and puts the address in the same place as get_address() It so happens in this implementation that 42 is printed, but other implementations may have different behavior.The * and & symbols mean different things when they are used as part of a type. When used in a type, * means that the type is a pointer type, while & means thetype is a reference type. Pointers allow us to work indirectly with objects.Pointers enable redirection, allowing a function to modify objects in a different scope. References can also be used to indirectly refer to other objects. A pointer holds the address of another object, while a reference just acts as another name for an existing object.Both pointers and references allow objects to be used across scopes. They both enable subtype polymorphism, a concept we will see later in the course. Pointers are strongly connected to arrays. Indexing into an array actually works through pointer arithmetic.
An array is simple collection of objects, built into C++ and many other languages. An array has the following properties: It has a fixed size, set when the array is created. This size never changes as long as thearray is alive. It holds elements of the same type.An array variable can be declared by placing square brackets to the right of the variable name, with a compile-time constant between the brackets, denoting the number of elements. The elements of an array are stored in a specific order, with the index of the first element being 0. Accessing any element of anarray takes constant time, regardless of whether the element is at the beginning, middle, or end of the array.We can explicitly initialize an array with an initializer list, a list of values in curly braces. This initializes the element at index 0 to 1, the element in array 1 to 2, and so on. If the initializer lists contains fewer values than the size of the array, the remaining array elements are implicitly initialized. For atomic elements, these remaining elements are initialized to zero values 1.The size of an array is the same as the size of the initializer list. Arrays in C++ are objects. In most contexts, there isn’t a value associated with an array as a whole 2.The system of values in C++ is very complicated and beyond the scope of this course. Instead, when we use an array in a context where a value is required, the compiler converts the array into a pointer to the first element in the array.C++ passes parameters by value. An array decays to a pointer when its value is required. This means that a function that takes an array as a parameter cannot guarantee that the argument value corresponds to an array of matching size.C++ supports certain arithmetic operations on pointers. An integral value can be added to or subtracted from a pointer. Pointer arithmetic is in terms of whole objects, not bytes.Each C++ type has its own pointer type. sizeof is an operator that can be applied to a type to obtain the number of bytes used to represent that type. For example, for a pointer of type T *, adding N to it moves N * sizeof(T) bytes forward in memory 3.Arithmetic is generally useful only on pointers to array elements, since only array elements are guaranteed to be stored contiguously in memory. Pointers can also be compared with the comparison operators, as in the following using the pointers declared above.The equivalence between array indexing and pointer arithmetic is what makes array access a constant time operation. The equivalence is also what makes passing arrays by value work – the result is a pointer, which we can still subscript into. Finally, it allows us to work with subsets of an array.An array only decays into a pointer when its value is required. When an array object’s value is not required, it does not decay into apointer. The address value stored in a pointer to an array is generally the same address as that of the array’S first element.The sizeof array / sizeof *array operator recovers the number of elements, as long as array is still an array. The operator produces the size of the whole array in bytes 5, as opposed to applying it to a pointer, which just produces eight bytes. If a program dereferences a pointer that goes past the bounds of the array, the result is undefined behavior 6.There are two general strategies for keeping track of where an array ends. Keep track of the length separately from the array. Store a special sentinel value at the end of the array, which allows an algorithm to detect that it has reached the end. The first strategy is what we used in defining the print_array() function above.The print_array() function above also demonstrates how to traverse through an array using an index that starts at 0 up to the size of the array, exclusive. This pattern of accessing elements is called traversal by index. We will see the second strategy next time when we look at strings.Traversal by pointer uses a pointer to walk through an array. We start by constructing a pointer that is just past the end of the array. Then use another pointer that starts at the first element, dereference it to obtain an element, and then increment it to move on to the next element.Traversal by index is the more common pattern when working with general arrays. It is the basis for the more general traversal by iterator, which we will see later in the course. Arrays are a fundamental abstraction that can be used to build more complex abstractions.
A string is a sequence of characters, and it represents text data. In the original C language, strings are represented as just an array of characters. C-style strings have a special null character, denoted by '\0'. A character array can also be initialized with a string literal. A string literal implicitly contains the null terminator at its end. The char type is an atomic type that is represented by numerical values.In C++, atomic objects with value 0 are considered to have false truth values. We will make use of that when implementing algorithms on C-style strings. Since C- Style strings are just arrays, the pitfalls that apply to arrays also apply to C-Style strings.C-style strings cannot be compared with built-in operators. When initializing a variable from a string literal, the variable can be an array, in which case the individual characters are initialized from those in the string literal. The C++ standard prohibits us from modifying the memory used to store a string.The built-in <cstring> header contains a definition for strlen. We can also use a for loop, with an empty initialization and body.The strcpy() function can be written more succinctly by relying on the behavior of the postfix increment operator. There are two versions of the increment operator, and their evaluation process is visualized in Figure 27. prefix increment operator, when applied to an atomic object, increments the object and evaluates to the object itself, which now contains the new value. postfix increment operator,. when appliedto an atomic. object, increment the object but evaluates to. the old value. There are also both prefix and postfix versions of the decrement operator (--). The test increments both pointers, but since it is using postfix increment, the expressions themselves evaluate to the old values. The assignment then evaluates to the left-hand-side object, so the test checks the truth value of that object’s value. As long as the character that was copied was not the null terminator, it will be true, and the loop will continue on to the next character.C++ strings are class-type objects represented by the string type 2. They are not arrays, though the implementation may use arrays under the hood. To print out the address value of a char *, we must convert it into a void *, which is a pointer that can point to any kind of object.C-style and C++ strings are to C-style strings as vectors are to built-in arrays. Technically, string is an alias for basic_string<char. A C++ string can be converted into a C- style string by calling .c_str() on it. C-Style Strings C++ Strings Library Header <cstring> <string> Declaration char cstr[]; char *cstr; string str Length strlen(cstr) str.length() Copy Value strcpy(cStr1, cstr2) str1 = str2 Indexing cstr [i] str[i] Concatenate strcat(c Str1,c Str2). C-style strings cannot be compared with the built-in operators – these would just do pointer comparisons. Instead, the strcmp() function can be used, and strcmp(str1, str2) returns: a negative value if str1 is lexicographically less than str2.Command-line arguments are arguments that are passed to a program when it is invoked from a shell or terminal. Command- line arguments are passed through arguments to main() function. The first argument is the number of command-line argument passed to the program. The second, conventionally named argv, contains each command- line argument as a C-style string.Command-line arguments also include the name of the program as the first argument. This is often used in printing out error messages from the program. The first argument is skipped, since it is the program name. Each remaining argument is converted to an int by the atoi() function.In C++, the cin stream reads data from standard input. Data is extracted into an object using the extraction operator >>. The extraction interprets the raw character data.The program above prints output to standard output, represented by the cout stream. Another word is entered, so the program reads and prints it out. Finally, the user in this example inputs an end-of-file character – on Unix-based systems, the sequence Ctrl-d enters an end of file. input and output redirection can also be used together. Using standard input, we can write a program that adds up integers entered by a user. The program will terminate either upon reaching an end of file or if the user types in the word done.Programs can use file streams to read and write files. They must include the <fstream> header. An ifstream object can be created from a file name. It can only be terminated by an end of file or other failed extraction.Best practice is to extract from an input stream, whether it is cin or an ifstream, in the test of a loop or conditional. That way, the test will evaluate to false if the extraction fails. An entire line can be read using the getline() function.An ofstream works similarly to an ifstream, except that it is used for printing output to a file. If so, the target string will contain the full line read: For words.in.The following program prints data to the file output.txt. The following shows the resulting data in output.
The const keyword is a type qualifier in C++ that allows us to prevent an object from being modified. For a simple type, the const keyword may appear on either side of the type: Only types with values may be declared as const. The following types do not have values: References; they alias objects that may have values but do not has their own. Arrays; as we saw previously, arrays are objects that don't have their own values.A reference cannot be declared as const itself, but it can refer to an object with const type. The const keyword can appear to the left of the & in a reference type, as in const int &. The object the reference is aliasing is not modifiable through the reference. However, the original object is still modifiable if there is a non-const way to refer to it. The example above has three names that refer to the same object.An array does not have a value of its own, so it cannot be assigned to as a whole. Pointers do have avalue, so they can be declared as const. We will see shortly that non-const to const conversions are allowed, but the other direction is prohibited. const is used to declare that an object that a pointer is pointing to is const. A const object can appear on the right-hand side of an assignment, since an assignment has value semantics. The conversion must not enable modifications that are prohibited without the conversion.The compiler only reasons about each conversion in isolation. This means that it does not allow a conversion from const to non-const even if we have some other means of modifying the underlying object. The other direction is allowed, however.C++ has several different categories of objects, including atomic, array, and class-type objects. In C++, a class type is introduced through the struct or class keyword. We will use the two keywords for different conventions when introducing our own data types.In C#, the struct keyword is used to introduce a new data type. After the struct definition, we can create objects that have Person type. Each Person object has its own subobjects name, age, and is_ninja located within the memory.We can explicitlyinitial a Person object with an initializer list. This initializes the struct member-by-member from the initializer lists. Unlike an array, structs do have a value, so they do not turn into pointers.By default, copying a class-type object copies each of the member variables. We can access individual members of a struct with the dot (.) operator. We will see in the future that we can customize how class types are copied by overloading the copy constructor and assignment operator.Passing a struct to a function produces a copy that lives in the activation record of the callee. This copy will die when Person_birthday() returns. Instead, we need to pass the struct indirectly, using a reference or a pointer.The following uses a pointer, and its execution is shown in Figure 33: Figure 33 Passing a pointer to a class-type object avoids making a copy of that object. The code uses the * operator to dereference the pointer, then uses the . operator to access a resulting Person object. structs can be composed with other kinds of objects, such as arrays. We generally do not pass structs by value, since creating a copy of a large struct can be expensive. Instead, we pass them by pointer or by reference.Declaring the object as const only prohibits modifications to the subobjects contained within the memory for the object. With foo declared as const, attempting to modify any of its members results in a compile error. A member can be declared mutable, which allows it to be modified even if the object that contains it is const.The fact that foo is const has no effect on whether or not x can be modified through a pointer that lives within foo. This means it is not a pointer to const, so modifying the value of the object it is pointing at is allowed.
 abstraction is the idea of separating what something is from how it works. An abstract data type (ADT) separates the interface of a data type from its implementation. An example of an ADT is the string type in C++, used in the following code.C ADTs have a single data member, but functions that operate on the data must be defined separately. C ADTs can provide customized initialization, overloaded operations such as the stream-insertion operator, member functions, and so on. We will start with the simpler model of C ADT, deferring C++ ADTs until next time.The Triangle ADT can be used to compute the perimeter of a triangle or to modify it by scaling each of the sides by a given factor. The naming convention for functions that are part of a C-style ADT is to prepend the function name with the name of the ADT.In this example, the code in main() need not worry about the implementation of Triangle_scale() or Triangle_perimeter() Instead, it relies on abstraction, using the functions for what they do rather than how they do it.Triangle ADT represents a triangle by two sides and an angle. The user of the Triangle ADT creates an object without an explicit initialization and then calls Triangle_init() on its address to provide the side lengths.The ADT functions all work on valid Triangles. The user of a C-style ADT may only interact with the ADT through its interface, meaning the functions defined as part of the interface. Except for Triangle_init() the ADTs all work only on valid Triangle objects. The REQUIRES clauses of the ADt functions make a distiction between Triangle objects and valid Triangle object.The space of values that represent valid instances of a triangle abstraction is a subset of the set ofvalues that can be represented by three doubles. For a triangle represented as a double for each side, the following representation invariants must hold: The length of each side must be positive.We document the representation invariants as part of the ADT’s data definition. We then enforce the invariants when constructing or modifying an ADT object by encoding them into the REQUIRES clauses of our functions. We adhere to the convention of only interacting with anADT through its interface. Usually, this means that we do not access the data members of an ADC in outside code.The Pixel ADT consists of just a data representation with no further functionality. Since it is a POD, its interface and implementation are the same, so it is acceptable to access its members directly. As with procedural abstraction, data abstraction is also defined in layers.Code that uses a matrix relies on the 2D abstraction provided by the interface. Adhering to the interface often means that we can’t test each ADT function individually. Instead of testing individual functions, we test individual behaviors, such as initialization.Let’s design and test an ADT to represent a coordinate in two-dimensional space. We will use polar coordinates, which represent a coordinates by the radius from the origin and angle from the horizontal axis. We start by determining the interface of the ADT: We then proceed to write some test cases, following the principles of test-driven development.We can run our existing test cases to get some confidence that our code is working. In addition, the process of coming up with a data representation, representation invariants, and function definitions often suggests new test cases. For example, it may specify that the if the radius is 0, then so is the angle.In C++, input streams generally derive from istream 3. This means that we can pass different kinds of input-stream objects to a function. We will see what this means specifically when we look at inheritance and polymorphism in the future.The istream type is actually an alias for basic_istream<char>. The same goes for ostream and basic_ostream< char>. To write data into an output stream, we use the insertion operator. The actual data written out depends on both the value itself as well as its type.We can use string streams to write unit tests. We can use the extraction operator to read data from an input stream. This allows us to chain insertion operations.An istringstream is used to represent input data for testing a function that takes in an input stream. We start with a string that contains the actual input data and then construct an ist ringingstream from that. We can then pass that istlingstream object to afunction that has a parameter of type istream &. When that function extracts data, the result will be the data from the string we used to construct the ist Ringstream. An ostringstream is also used to test a function taking in an output stream.
C++ allows the data and functions of an ADT to be defined together. It also enables an ADTs to prevent access to internal implementation details. Our convention in this course is to use the word struct to refer to C-style ADTs, as well as the struct keyword to define them.The C-style definition and use of the triangle ADT is compared with the C++ version. We can create and use a Triangle object using the same syntax as we use for accessing a member variable: <object>.In the C style, we had to separately create the Triangle object and then initialize it with a call to Triangle_init. In the C++ style, object creation and initialization are combined – we will see how later. When invoking an ADT function, in the C case we have to explicitly pass the address of the object we are working on.The C-Style Struct C++ Class uses the const keyword to declare a pointer to const. In the C++ style, we don't have an explicit parameter where we can add the const. Instead, we place the keyword after the parameter list for the function. The compiler will then make the implicit this parameter a pointer.C++ allows us to refer to members from within a member function without the explicit this-> syntax. This is also the case for invoking other member functions. In both cases, the compiler can tell that we are referring to members of the class.In general, we should avoid declaring variables in a local scope that hide names in an outer scope. With C-style structs, however, we have to rely on programmers to respect convention and avoid accessing member variables directly. Later, we will discuss protected members that are accessible to derived classes.The private: keyword is used to declare a class's default access level. This access level, however, is rarely used. In this example, the members a, b, and c are declared as private, while Triangle() and perimeter() are public.A constructor is similar to a member function, except that its purpose is toinitialize a class-type object. In most cases, C++ guarantees that a constructor is called when creating an object of class type. The exception is aggregate initialization, where an initializer list is used to directlyinitialize the members of a class.There are many forms of syntax for initializing a Triangle object, all of which call a constructor. When no arguments are provided, the zero-argument, or default, constructor is called. We will discuss this constructor in more detail later. We can still use initializer-list syntax for a non-aggregate.The Triangle constructor has an implicit this parameter that points to the object being initialized. Like a member function, we can leave out this-> to access a member, as long as there is no local name that hides the member. However, there is a problem with the definition above: the statements in the body of the constructor perform assignment, not initialization.C++ provides two mechanisms for initializing a member variable: directly in the declaration of the variable, or through a member-initializer list. A member- initializer list is syntax specific to a constructor. It is a list of initializations that appear between a colon symbol and the constructor body.Every object in C++ is initialized upon creation, whether the object is of class type or not. If no explicit initialization is provided, it undergoes default initialization. Objects of atomic type (e.g. int, double, pointers) are default initialized by doing nothing.An array of class-type objects is default initialized by calling the default constructor on each element. If no such constructor exists, or if it is inaccessible (e.g. it is private), a compile-time error results. A class can have multiple constructors. This is a form of function overloading, which we will return to in the future.The C++ ADTs provide a means of accessing the abstract data through get and set functions (also called getters and setters or accessor functions) These are provided as part of the interface as an abstraction over the underlying data.Good abstraction design uses encapsulation, which groups together both the data and functions of an ADT. With a class, we get encapsulation by defining both member variables and member functions. A proper abstraction also provides information hiding, which separates interface from implementation.C++ hides information from the sight of the users of an ADT. The standard mechanism to do so in C++ is to place declarations in header files and definitions in source files. With a class, we place a class definition that only contains member declarations in the header file.The Triangle ADT is a C++ class with a private interface. The member-initializer list is always in the order in which it is declared. This is the case regardless if some members are. initialized at the declaration point and others are not.When a class has multiple constructors, it can be useful to invoke one constructor from another. This allows us to avoid code duplication, and it also makes our code more maintainable. In order to delegate to another constructor, we must do so in the member-initializer list.The constructor creates a new, temporary object and then throws it away. If we invoke a different constructor from within the body, it does not do delegation.
C++ classes provide two features that are fundamental to object-oriented programming. Inheritance: the ability for a class to reuse the interface or functionality of another class. Subtype polymorphism: The ability to use an object of a more specific type in a more general type.Chicken and Duck share a lot of functionality, since chickens and ducks are both types of birds. We write Bird as a base class, then write Chicken and Duck as classes that inherit or derive from Bird. We place the common functionality in Bird, which then gets inherited by the derived classes.Chicken derives from Bird, and the public interface of Bird is also supported by Chicken. Functionality that is specific to a particular kind of bird goes in the class for that bird.The layout of a derived-class object contains a subset that matches the layout of its base-class. In C++, a derived class constructor always invokes a constructor for the base class.In most cases, a constructor is invoked when a class-type object is created. Similarly, a destructor is invoked When a class is dying. We will cover destructors in more detail later in the course. For completeness, the following is an implementation of Duck as a derived class of Bird:. C++ follows a “socks-and-shoes” ordering when constructing and destroying objects. In the case of a derived class, C++ will always construct the base-class subobject before initializing the derived-class pieces.When a Chicken object is dying, first the code in the Chicken destructor runs. This is true regardless of whether or not an explicit call to the Bird constructor appears. We see the same ordering in Duck construction and destruction.When a member access is applied to an object, the compiler follows a specific process to look up the given name. The process starts by looking for a member with that name in the compile-time or static type of the object. If no member is found, the process repeats the process on the base class of the given type. If the type has no base class, a compiler error is generated. If name lookup finds a set of overloaded functions within the same class, the compilation performs overload resolution to determine which overload is the most appropriate.The name lookup process for member accesses can be very complex. For example, consider the following example. For myrtle.get_age, the compiler looks for a get_age member in Chicken. There is none, so the compiler Looks in Bird. There's a get-age member, so it checks that the member is accessible and is a function that can be called with no arguments.When looking up d.x, the compiler finds a member x in Derived. However, it is a member function, which cannot be assigned to an int, so the compiler reports an error. Similarly, when looking up.foo, the compilation does not consider the member foo that is defined in Base; that member is hidden by the foo defined in Derive. For myrtle.undefined, the. compiler looks for an undefined member in Chicken. There is no such member, and Chicken has no base class, so it reports anerror.C++ does not consider the context in which a member is used until after its finds a member of the given name. This is in contrast to some other languages, which consider context in the lookup process itself. On occasion, we wish to access a hidden member rather than the member that hides it. The most common case is when a derived- class version of a function calls the base-class version as part of its functionality.The member variable age is an implementation detail. We can declare age to be protected, which allows derived classes of Bird to access the member but not the outside world. Or we can use the public get_age() function instead.We already have a public get function, so we can just use that. For age, we already have  a publicget function, and we can use that:  age. For gender, we can  use the publicget for gender.
Polymorphism is the ability of a piece of code to behave differently depending on the context in which it is used. Ad hoc polymorphism refers to function overloading. parametric polymorphism is in the form of templates subtype polymorphism. C++ allows both top-level functions and member functions to be overloaded.In C++, functions can only be overloaded when defined within the same scope. If functions of the same name are defined in a different scope, then those that are definition in a closer scope hide the functions in a further scope. The following is an example of overloaded member functions.The function signatures of member functions must differ for overloading to work. Subtype polymorphism allows a derived-class object to be used where a base-class one is expected.C++ allows implicit upcasts, which are conversions that go upward in the inheritance hierarchy. C++ allows a reference or pointer of a base type to refer to an object of a derived type. In either case, a copy is avoided. implicit downcasts are prohibited by C++ even though bird_ref and bird_ptr actually refer to Chicken objects. Since the conversions may be unsafe, they are disallowed by the C++ standard. While implicit downcast are prohibited, we can do explicit downcasts with static_cast.Subtype polymorphism allows us to pass a derived-class object to a function that expects a base-classobject. Consider this example: This results in a compiler error:. C++ gives us the option of either static binding or dynamic binding. Dynamic binding is more efficient and can be done entirely at compile time. In order to get dynamic binding instead, we need to declare the member function as virtual in the base class.With dynamic binding, the only change we need to make to our code is to add the virtual keyword when declaring the base-class member function. It can only be applied to the declaration within a class. If the function is subsequently defined outside of the class, the definition cannot include the virtual keywords.In C++, dynamic_cast can only be applied to classes that are polymorphic, meaning that they define at least one virtual member function. We would need a branch for every derived type of Bird, and we would have to add a new branch every time we wrote a new derived class. The code also takes time that is linear in the number of derived classes.The full lookup process is shown below. The compiler looks up the member in the static type of the receiver object. It is an error if no member of the given name is found in its static type or its base types. If the member is a virtual function, the access uses dynamic binding.Dynamic binding requires two conditions to be met to use the derived-class version of a function. The member function found at compile time using the static type must be virtual. The derived- class function must have the same signature as the function found in the base class.There is no indirection in the calls top.f1() and mid.f2() so there is no difference between the static and dynamic types of the receivers. The following are some examples of invoking these functions.A common mistake when attempting to override a function is to inadvertently change the signature, so that the derived-class version hides rather than overrides the base-class one. Rather than having the code compile and then behave incorrectly, we can ask the compiler to detect bugs like this.In some cases, there isn’t enough information in a base class to define a particular member function. We still want that function to be part of the interface provided by all its derived classes. In the case of Bird, for example, we may want a get_wingspan() function that returns the average wingspan for a particular kind of bird. Instead, we declare get_wingpan() as a pure virtual function, without any implementation in the base class.The Bird class is said to be abstract. In order for a derived class to not be abstract itself, it must provide implementations of the pure virtual functions in its base classes. With a virtual function, a base class provides its derived classes with the option of overriding the function’s behavior. If a derivedclass fails to override the function, the derived class is itself abstract.With subtype polymorphism, we end up with two use cases for inheritance. Deriving from a base class that isn’t an interface results in both implementation and interface inheritance. The latter is useful to work with a hierarchy of types through a common interface.
A container is an abstract data type whose purpose is to hold objects of some other type. We have already seen two examples of containers: built-in arrays and vectors from the standard library. Let’s define our own container ADT.The ADT will allow the following operations: Inserting a value into a set. Removing a value from a set – it will just do nothing. Count the number of items in the set. Print a character representation of a set to an output stream.The public interface includes a default constructor and member functions to insert or remove an item, check if an item is in the set, obtain its size, and print a representation of the set to a stream. The public interface also includes a constant, MAX_SIZE, that denotes the maximum size of a set. static means that a member variable is not associated with an object of the class, but with the class as a whole. A member variable that isn’t a compile-time constant cannot be initialized at the point of declaration.In C++, a local or member variable that is an array must have a size that is known to the compiler. Pointer arithmetic (including array accesses) requires the compiler to know the size of an object at compile time.We rely on existing types to represent the data of our IntSet. For the elements themselves, we use a built-in array, with MAX_SIZE as its capacity. In the future, we will see how to eliminate the fixed-size restriction by storing the elements indirectly using a dynamic array. We will see that this raises issues of memory management and learn how to resolve them.The size_t type represents only nonnegative integers, and the C++ standard guarantees that it is large enough to hold the size of any object. Since it does not represent negative integers, we could have used it for num_elements rather than defining 0 <= num_Elements as a representation invariant.Unsigned integers can lead to subtle programming errors. C++ has integral types that are unsigned, which do not represent negative numbers. Another common error is incorrectly iterating backwards over a sequence.We define the constructor and member functions of IntSet, defining them as they would appear in a source file, outside the class definition. We require only a default constructor for IntSet. We cannot rely on a compiler-generated implicit one: it would default initialize num_elements to an undefined value.The representation invariants tell us that the valid items are the first num_elements in elements. They can be stored in any order, so we need to iterate through them to see if the value is in the set. When we find an item, we can return immediately without checking the rest of the elements. On the other hand, if we get through all the elements without finding the given value, it is not in theSet so we return false.For inserting into the set, we first assert the requires clause, which ensures that our invariant of num_elements <= MAX_SIZE is never violated. To remove an element, we need to know its location in the array, which would require iterating through the elements to find it. We define a private helper function to do so and call it in both places.The representation of IntSet places no restrictions on the ordering of elements in the array. This simplifies the implementation of insert() and remove() but it requires contains() to iterate over every element in the worst case. An alternate representation would be to require that the set elements are stored in sorted, increasing order.To insert an item, we can no longer just put it after the existing elements. Instead, we need to store it at its appropriate sorted position. This requires moving existing elements out of the way if necessary.Removing from an ordered set requires shifting elements to preserve the representation invariants. The advantage of sorting is that we don’t have to look through all the elements to determine the location of a value. Instead, we can use binary search, which eliminates half the search space in each step.Since half the search space is eliminated in each step, this algorithm takes time that is logarithmic in the size of the set. The following implements this algorithm:. 
C++ allows operators to be applied to class types through operator overloading. Most operators in C++ can be overloaded. An operator overload requires at least one of the operands to be of class type 1. The behavior of operators on atomic types cannot be changed.The + operation is applied to two IntSets. The compiler looks for a function with name operator+ that can be applied. For most operators, the function can either be a top-level function or a member of the type of the left-most operand.Overloaded operators can take arguments by value or by reference, like any other function. Most operators can be overloaded either as top-level or member functions.The following overloads insertion of an IntSet. We saw previously that inserting to a stream evaluates back to the stream object. To support this properly, our overload returns the given stream object by reference.Friend declarations are sometimes used with operator overloads. Some operators can only be overloaded as member functions. In the future, we will see that we can use a friend declaration to give outside class or function access to private members.C++ provides a mechanism for specifying type arguments. We write a generic version, parameterized by one or more template parameters. The compiler then instantiates a specific version of the code by substituting arguments for the parameters.The header begins with the template keyword, followed by a parameter list surrounded by angle brackets. Within the parameter list, we introduce a template parameter by specifying the kind of entity the parameter can represent. A template may have more than one parameter, and it can also have a parameter that is of integral type.UnsortedSet takes two arguments, one for the element type and the other for the size of the container. The scope of a template parameter is the entire entity that follows. The actual type argument used to instantiate Unsorted set may be something small like int.When we use UnsortedSet with a particular type argument, the compiler actually plugs the argument in for T. We can also define a function as a template, resulting in a function template. As with a class template, we define a template by preceding it with a template header, which introduces one or more template parameters.The max() function template can only be applied to a type that supports the > operator. Unlike a class template, the compiler is able in most cases to deduce the template argument from the arguments to the function call.The offending line of code is the one marked as “required from here’ – it is the line that attempts to call max() on two Duck objects. The C++ compiler only needs access to declarations when compiling code that uses a class or a function defined in some other source file. However, this is not the case for class and function templates. The compiler must actually instantiate the definitions for each set of template arguments.It is often the case that a single file inadvertently #includes the same header file more than once. We can just define the template directly in the header file itself. It is still good practice to separate the declarations from the definitions. headers generally have include guards that arrange for the compiler to ignore the code if the header is included a second time. The #ifndef and #define directives are the opening of the include guard, and the #endif closes it. A widely supported but nonstandard alternative is #pragma once.We must tell the compiler that contains() is a member of UnsortedSet<T>. However, before we can use the name T, we need to introduce it with a template header. Defining a member function outside the definition of a class template differs from that of a regular class.The fill_from_array() template must be parameterized by the element type. The set is passed by reference, to avoid making a copy and to allow the function to modify the original set. The body of the function template just iterates over the array, inserting each element into the set.In designing an ADT, we have the choice of static polymorphism or dynamic polymorphism. Dynamic polymorphism comes with a runtime performance cost. For a container, a program may make many calls to insert items, remove items, check whether an item is in the container.A type alias is a new name for an existing type. We can introduce a type alias with a using declaration. The example above introduces the name UnsortedIntSet as an alias for the type Uns sortedSet<int>.A using declaration (but not a typedef) can also define an alias template, which introduces a new name that is a template for a set of types. A simple alias can also be defined with the typedef keyword. The syntax is in the reverse order of a using declaration: the existing type first, then the new alias.The Liskov substitution principle states that in order for a type to be a subtype of another, it must be met. We will start looking at dynamic memory in more detail next time.Liskov substitution principle says that an object of type S can be substituted without undesirable effects. If the requirement above is not satisfied, an object would be a derived type of T but not a subtype. A classic example is a ToyDuck class that derives from Duck..com is a social networking site that lets users post photos of themselves on the Web.
An object is a piece of data in memory, located at some address in memory. An object also has a storage duration that determines its lifetime. In this course, we consider three storage durations: static, automatic and dynamic. static local variable is a local variable declared with the static keyword. Rather than living in the activation record for a function call, it is located in the same region of memory as other variables with static storage duration. There is one copy of each staticLocal variable in the entire program.The lifetime of the associated object corresponds to the variable’s scope. The scope of a variable begins at its point of declaration and ends at the end of the scope region in which it is defined. A scope region can be the body of a function, a whole loop or conditional.The scope of a variable declared within a block is from its point of declaration to the end of the block. The lifetime of an object i begins when the loop starts and ends when the loops exits. Returning the address of a local variable results in a pointer that refers to a dead object. Dereferencing the pointer produces undefined behavior.When the program calls func1() it places the activation record on the stack. The call returns the address of x, which gets stored in z. When the call returns, its activation record is destroyed, so z is actually pointing at a dead object. The memory for that activation record can then be reused for something else.The new operator creates an object not in some activation record, but in an independent region of memory called the heap. The heap is the total memory associated with a running program.The stack starts at the top of the address space, and it grows downward when a new activation record is created. The syntax of a new expression consists of the new keyword, followed by a type, and an optional initialization using parentheses or curly braces.A new expression does the following: Allocates space for an object of the given type on the heap. Initializes the object according to the given initialization expression. Evaluates to the address of the newly created object.The expression delete ptr; does not kill the ptr object – it is a local variable, and its lifetime ends when it goes out of scope. Rather, delete follows the pointer to the object it is pointing to and kills the latter. We can continue to use the pointer object itself:. A new array expression does the following: Allocates space for an array of the given number of elements on the heap. Initializes the array elements according to the given initialization expression. If no initialization is provided, the elements are default initialized. Evaluates to the address of the first element of the newly created array.The lifetime of a dynamic array begins when it is created by a new array expression. It ends when the array-deletion operator delete[] is applied to the address of the array’s first element. We cannot delete an individual element of an array.When a class-type object dies, its destructor is run to clean up its data. For a local object, this is when the associated variable goes out of scope. If the object is an element of an array, it dies when the array dies, so the destructor runs.The body of C’s constructor runs first, and then the members are destroyed in reverse order. The order in which the bodies of the destructors are run is the reverse of the constructors. When execution reaches the end of main() both c1 and c2 go out of scope, so their associated objects are destroyed.Dynamic memory must be explicitly managed by the programmer. Improper management can result in many kinds of errors that are unique to dynamic memory. The most common error with dynamic memory is a memory leak.Memory leaks result in a program using more memory than it needs. This is problematic on systems that run more than one program at once. It is our responsibility as programmers to write well-behaved programs that avoid memory leaks.Deleting a dynamic object is not enough to avoid a memory error. If we keep around its address, we have a dangling pointer – a pointer that points to a dead object. If a pointer is going to live past the object that it is pointing to, it is good practice to set it to null.Dynamic memory adds another use for indirection through a pointer or reference. Since a dynamic object is not directly associated with a variable, we are forced to interact with the object indirectly. Notice that we did not set ptr2 to null – when we apply delete to it, ptr2 itself is about to die, so it will not live on past the object it is pointing to.We will see that this results in nontrivial memory-management issues. We will learn how to address them.
The compiler and runtime automatically manage the lifetime of objects associated with static, local, and member variables. An automatically managed array must have a size that is known at compile time, so that the compiler can properly manage it. We can leverage automatic memory management and destructors by wrapping up the management of a dynamic resource in a class.We will arrange for the constructor of a class-type object to allocate a resource and for the destructor to release that resource. This strategy is called resource acquisition is initialization (RAII) and it is also known as scope-based resource management. The following is a class that manages a dynamic array.DynamicIntArray manages an array in dynamic memory. When the object associated with darr is created, it allocates a dynamic array. When darr goes out of scope, its associated object dies. The DynamicIntArray destructor is run. The destructor deletes the array, cleaning up the resource that it was using.The class definition for UnsortedSet is as follows: elements points to the start of the sole dynamic array associated with the set. capacity is the size of the dynamic array that elements point to. The constructor allocates a dynamic array of size INITIAL_SIZE.Grow() member function doubles the capacity of the set. In C++, an array has a fixed size, even if it is dynamic. We allocate a new dynamic array, copy over the elements, and discard the old array.The destructor does not cause the object to die. By decoupling the storage for the elements from that of the UnsortedSet object, we have also decoupled their lifetimes. If the old storage no longer meets our needs, we can replace it with different storage.The destructor merely runs when the object dies – it gives the object a chance to put its affairs in order while it is on its deathbed. The representation invariant that there is exactly one dynamic array associated with each UnsortedSet ensures that after the destructor runs, there is no longer a live array associated to the dying set.The code creates a set s1 and adds five items to the set, filling it to capacity. It then creates s2 as a copy of s1; by default, this does a member-by-member copy. We then add an item into s2, causing it to grow and delete its old array. This is the same array that s1.elements is pointing to, so that when we proceed to print out s1 it accesses a dead object.
C++ copying an UnsortedSet ultimately results in undefined behavior. By default, a copy just copies over the members one by one, as we saw when we first discussed class-type objects. Initialization as a copy occurs when we pass an object by value.Copy constructor is always called when a class-type object is created. It takes a reference to an existing object as the parameter. The parameter must be passed by reference – otherwise, a copy will be done toinitialize the object.Copy constructor copies an object into an existing object rather than a new one. Assignment is another situation where an object is copied. An assignment expression consists of a left-hand-side object and the = operator.The assignment operator is an implicit definition of the copy constructor. It does a member-by-member copy of an object. The left-hand-side object must be returned.For most class types, a member-by-member copy is sufficient. For a type that manages a dynamic resource, aMember-by.member copy generally results in incorrect sharing of a resource. Consider the following code that copies an UnsortedSet.The fundamental problem is that the implicitly defined member-by-member copy is a shallow copy. This violates the representation invariant that each set has its own array. Instead, we need a deep copy, where we make a copy of the underlying resource rather than having the two sets share the same resource.The custom copy constructor for UnorderedSet performs a deep copy, providing the new set with its own array. The function first deletes the old array before creating a new one. While this assignment operator works in most cases, it fails in the case of self assignment. An expression such as s2 = s2 will delete s2 before proceeding to access the elements in the subsequent loop.The assignment should have no effect when both operands are the same object. We do so as follows: The this pointer points to the left-hand-side operand, while the parameter rhs is an alias for the right-hand side operand. We need to obtain the address of rhs to compare to the address stored in the this pointer. If the two addresses are thesame, then the two operands is the same.The destructor, copy constructor, and assignment operator need to be custom. C++ provides implicit definitions of each of the big three. When a class manages a resource, however, the programmer must provide custom versions.The Foo class has a str member variable that we will use to distinguish between different Foo objects. The constructors, assignment operator, and destructor all print the value of str. This prints the following when run:. In func() the second parameter is passed by value, so the parameter object is initialized as a copy of the argument. This invokes the copy constructor, which prints Foo copy ctor banana. In main() the local objects are destructed in reverse order: z is destructed first, producing Foo dtor apple. The last four lines of output are the result.If an object is of class type, its destructor is run. If it is not, the destructor must be used to free the memory. This can be a problem if the destructors use different types of binding.A base class should always declare the destructor to be virtual if the class will be used polymorphically. If the base class destructor has no work to do, it may be defaulted.Valgrind does not show a memory leak. Valgrind is a popular social network for people who want to share their memories.
A sequential container is a container that holds elements and allows them to be accessed in sequential order. The simplest sequentially container is an array, which stores its elements contiguously in memory. We can also traverse over arrays by index, using random access to get to an element.Sequence abstractions based on contiguous memory have the drawback of inefficient insertion at the beginning or middle of the sequence. To insert an item at a particular position, we need to first move the elements at that position and later out of the way. A noncontiguous data structure can use pointers to keep track of each element’s location.We define the Node type as plain-old data, using the struct keyword and accessing the members directly. For now, we will stick to int as the element type. The remaining Node member is a pointer to the next Node in our sequence. We use a null pointer as a sentinel denoting the end of the sequence.IntList ADT internally maintains a sequence of nodes. We refer to the sequence of node as a linked list. The nodes are stored indirectly from the IntList object.The next step is to determine the representation invariants. We have already decided to use a null pointer to denote the end of the sequence of nodes. There are two further invariants: a node is associated with exactly one list, and there are no cycles among the next pointers of the nodes.The constructor must ensure that the list is initialized to satisfy the representation invariants. The empty() function just needs to check whether first is null. The left-hand side of an assignment must be an object, not a temporary value. front() must return an object by reference.In both cases, we construct a new Node in dynamic memory. We then set its datum to be the value that is being inserted. In pop_front() we again assert the REQUIRES clause.In both cases, we need to assign the value of first->next to first. We also need to properly manage dynamic memory; in particular, we must delete the node that is being removed, as it is memory that no longer will be used. In the second case, the first node’s next is pointing to the second node in the list, so first should end up pointing at that node when the first one is removed.The pop_front() function is used to remove an element from the front of a linked list. The function uses a temporary to keep track of the first node in the list. It can be used to delete the node that is being removed.The truth value of a null pointer is false, so the condition of the loop will evaluate to false. The body then executes, and it uses the -> operator to access the datum member of the node that node_ptr points to. The loop update then copies the node’s next pointer into node_ ptr, moving node_ pointer to point to the next node. When the iteration reaches the last node in the list, its next is null, soThe update sets node_ pointers to null.The destructor does not free the nodes’ memory, so we need to write a custom destructor instead. The copy constructor delegates to the default constructor to make the list empty, then calls push_all() to copy all the elements from the other list. Both the copy constructor and assignment operator perform a deep copy of another list’s resources.The assignment operator does a self-assignment check. The destructor just calls pop_all() to remove all the elements and free their associated nodes. We already have a pop_front() function that removes a single item, so we just need to repeatedly call it until the list is empty. The push_all(){ function needs to iterate over each of the elements in the other list, adding them one by one to the current list.With our current list representation, push_back() must traverse the entire list to insert the new element. This is a very inefficient algorithm. The core problem is our list implementation only keeps track of the first node, but we need to insert after the last node. We update our representation invariants so that an empty list is represented by both last and first being null.We can only get to the second-to-last node of a list by traversing the entire list. We can modify our representation once more to enable backwards traversal. We add a prev pointer to each node. This is now a doubly linked list, since each node has two links.The original list is a singly linked list. We can generalize the IntList class to hold objects of other types by making it a template. By placing the Node struct inside the List template, each instantiation of List will have its own Node type. Now that our container is a template, we pass elements by reference.A good rule of thumb is to pass a function parameter by reference if the function parameter’s type is a template parameter. The latter may be instantiated with a large class type.
We have seen two patterns for iterating over a sequential container. We need to provide a different interface for iteration over a list. We can try to follow the same strategy from outside the class. traversal by index is not an appropriate pattern for a linked list. Linked lists do not provide random access. Since they are not array-based, accessing an element in the middle of the list cannot be done with pointer arithmetic.Traversal by pointer starts with a pointer to the beginning of a sequence and iterates by moving that pointer forward to each subsequent element, until that pointer reaches past the end of the sequence. We use an object called an iterator to iterate over the elements. To traverse with an iterator, it must provide the following operations: 1 dereference ( prefix *) increment ( prefix ++) equality checks (== and !=). An iterator is a class-type object that has the same interface as a pointer. We provide the sameinterface by overloading the required operators. Unlike most class types, we pass iterators by value – they are generally small.A list iterator is an abstraction of a pointer to a node. The call list.begin() returns an iterator constructed from first. The past-the-end iterator returned by list.end() is represented by a null pointer.The end condition for the traversal in print() is when the node pointer is null. It makes sense to use a null pointer to represent a past-the-end iterator.The Node struct is private, so it cannot be accessed from outside code. The Iterator type is associated with List, so should be encapsulated within the List template. The scope of a class member begins at the member declaration and includes the rest of the class body. We can now implement the member functions of Iterator.The operator*() function is a member of Iterator, which itself is a List<T> – thus, we need two scope-resolution operators when referring to the function. The dereference operator requires that the iterator is dereferenceable, which means that it is pointing to a valid element in the container.The operator++() function modifies the iterator by moving it to “point to the next element, so it cannot be declared as const. As with dereference, the past-the-end iterator cannot be incremented – node_ptr would be null, and there wouldn’t be a next pointer to move the iterator to. In keeping with the contract for postfix increment, the function returns a copy of the original iterator by value.C++ requires the typename keyword before a dependent name that refers to a type. The reasons are beyond the scope of this course, but they have to do with the way the compiler instantiates templates. An unqualified name, one without the scope-resolution operator, never needs the typamen keyword.Two iterators are equal if either they are both past the end, or they “point to” the same element in the same list. Comparing two iterators does not require them to be dereferenceable or even pointing to a valid element. The operators do not have a REQUIRES clause.The list class is not part of the List interface, so we don't need a user-defined constructor. Instead, we define two constructors: an explicit default constructor that makes the iterator a past-the-end iterator and a constructor that takes in a pointer to a node.A private member is only accessible from within the scope of the class that defines the member. A nested class can access private members of the outer class, but not vice versa. The solution to the problem above is a friend declaration.The friend declaration completes our iterator implementation. We can now perform a traversal by iterator: This is just an abstraction over a loop that uses a node pointer directly. The traversal ends when the iterator reaches a null pointer, just like the node-pointer loop.The standard-library sequences all support the iterator interface. The common interface allows us to write generic functions that work on any sequence. For instance, we can write a function template for finding the maximum element in a sequence.The standard <algorithm> library contains many function templates that operate on iterators. We can use max_element() with any iterator and element type, as long as the element type supports <: As usual with function templates, the compiler deduces the template parameter from the function arguments.An iterator that is pointing to an invalid object is said to be invalidated. In general, modifying a sequence can invalidate existing iterators. An iterator may be invalidate even if the element it's pointing to is not removed. This is because dereferencing the iterator results in undefined behavior.A member function’s documentation should indicate whether it may invalidate iterators. If the new size() is greater than capacity() then all iterators and references (including the past-the-end iterator) are invalidated. Otherwise only the Past-The-End iterator is invalidated, and the current element is moved to a different location.
We have seen several forms of abstraction, where we use something for what it does rather than how it works. It can be useful to refer to an abstraction when we are still in the middle of implementing it. For instance, our definition of a linked-list node refers to itself: Such a definition is recursive, where it uses itself as part of its definition.When factorial(3) is evaluated, an activation record is created, and the parameter n is initialized with value 3. Within the context of that activation record, the body of factorial() is executed. The body runs, returning 1, replacing the function call in the caller.The factorial function works by using factorial() as an abstraction, even while we are still in the midst of implementing that abstraction. We call this “the recursive leap of faith” – we trust that the abstraction works, even if we haven’t finished writing it yet. In general, a recursive abstraction requires the following: base cases, which are cases we can implement directly without recursion, and recursive cases.The problem of computing the number of ducks on a duck farm is similar. Assume that a duck lays three eggs each month, once the duck is at least a month old itself. An egg takes a month to hatch, and our ducks never die. We start by working out the first few months by hand.The number of ducklings in a month is three times the number of adult ducks in the previous month. The total number of ducks is 200 at month 5.Recursive algorithms are not just for math problems. The following is an algorithm for lifting a box of heavy books. As another non-math example, we write a recursive function to reverse the contents of an array.Reverse() is an efficient algorithm for an array of size n. For an empty array or an array with one element, nothing needs to be done, constituting the base case. The subproblem is the set of elements in \([left + 1, right - 1]\), which is closer to the base cases of the two arrays.The algorithm uses only a single activation record, resulting in constant space. The fundamental difference is that this algorithm solves the subproblem after doing the extra work for the original problem, i.e. swapping the two ends.Many compilers recognize tail calls and perform tail-call optimization (TCO) TCO is not restricted to recursive functions; as long as a function call is the last thing that happens in its caller, it is a tail call and the optimization can apply. TCO can reduce the space usage of the computation by a large factor.In order for a computation to be tail recursive, it must do all its work in the active flow of the computation, before making a recursive call. A computation that does its work. in the passive flow must wait until a. recursive call completes before doing work. As a concrete example, the prior. recursive implementation of factorial() is not tail. recursive, since it does its. work in a passive flow. The multiplication must be done after the recursive call returns.A function is linear recursive if it is recursive, but each invocation of the function makes at most one recursive call. The various recursive factorial() and reverse() functions above are all linear recursive. To retain the same interface, we move the actual computation to a helper function.A function is tree recursive if a single invocation of the function can make more than one recursive call. Such a function subdivides a recursive case into multiple subproblems. Drawing out the recursive call graph for a tree-recursive function, we end up with a branching structure that resembles a tree.Both iteration and recursion have the same computational power. An iterative algorithm can be converted to a tail-recursive implementation and vice versa. Techniques such as dynamic programming can be used in general to convert a recursive algorithm to an iterative one.
The data representation of a linked list is an example of structural recursion. The empty list is the base case, represented by a null pointer. A non-empty list is a recursive case; it can be subdivided into the first node.Recursive definition of a list is natural to process a list with a recursive function. Base case of the recursive function will be the minimum-size list allowed by the function. As an example, the following is a function to compute the length of aList.The algorithm is based on a single datum. The base case is a list with one element. For a larger list, we can break it down recursively as follows.A tree is a data structure that is, naturally, tree recursive. A non-empty tree is subdivided into a datum and several smaller trees. The root is the node that originates the branching structure.The height of a tree is the number of levels at which it has elements. Equivalently, it is the length of the longest path from the root to a leaf node. Algorithms on trees are often written as tree-recursive functions. The size of an empty tree is zero.The size of a non-empty tree is the size of the left child and the right child, plus one for the root datum. We use a Node struct, but it now has a datum and pointers to left and right Nodes. Like a list, we use a null pointer to represent an empty tree. We can now implement the size() function:. The root adds one additional node to the part of the path contained in a child. The longest such patch is just one node longer than the longest path in the child subtrees. We use std::max() to obtain the longer path from the two child trees, then add one to the result to account for the root node.A binary search tree (BST) is a binary tree whose elements are stored in an order that maintains a sorting invariant. A BST is either: empty, or a root datum with two subtrees such that: Every element in the left subtree is strictly less than the root datumm. Every element. in the right subtree. is strictly greater than theroot datum.The left and right subtrees meet the requirements for a binary search tree. Every element in the left subtree is less that the root datum, and every elements in the right subtree are greater than the root. A binary searchTree is thus named because searching for an element can be done efficiently, in time proportional to the height of the tree rather than the size.A search algorithm need only recurse on one side of the tree at each level. For example, in searching for the element 2 in the BST in Figure 84, the element must be in the left subtree, since 2 is less than the root element 6. If the value is greater than theroot element, it is in the right subtree.The body of a linear- or tail-recursive function may contain more than one recursive call, as long as at most one of those calls is actually made. Let us consider another algorithm, that of finding the maximum element of a BST, which requires there to be at least one element in the tree. If there is only one element, then the lone, root element is the maximum.The algorithm is tail recursive and runs in time proportional to the height of the tree. If the right subtree is empty, then the root is the maximum. Otherwise, the maximum item is the largest element in the right tree.We define a BinarySearchTree class template as the interface for a BST. As with a list, we define Node as a nested class of BinarySearch tree. The contains() member function differs from the one we defined before. We define the latter as a private helper function.A public static member function can be called from outside the class using the scope-resolution operator. Just like a static member variable is associated with a class rather than an individual object, a static members function is not associated with an individual.BST does not guarantee that it will be balanced. In fact, inserting items in increasing order results in a maximally unbalanced tree. There are more complicated binary-search-tree implementations that do guarantee balance.
Any_of_odd() works over any sequence of integers, determining if there is and odd element in the sequence. The template is generic over the iterator type, but not over the condition that an element must meet. We can then use any_of-odd() with any sequence type, as long as the elements are integers.The memory for a program includes a segment that stores the program’s code. We can use a function to represent such a computation. Once we have a function, the compiler translates it into machine code, which is placed in memory in the text segment when the program runs.The address-of operator is an optional operator in C++. The compiler implicitly inserts the operator for us. We can call a function through a pointer by first dereferencing the pointer.We can now write a generic any_of() that is parameterized both by an iterator type as well as a function to test an element. Since different iterators may have different types, we use a template parameter to allow an arbitrary kind of iterator.Any_of() and is_positive() can determine whether a sequence contains an element that is greater than zero. For the test of whether an element satisfies a condition, we add a function parameter that is a pointer to a function. We call it using parentheses like any other function, and the compiler automatically dereferences the pointer to get to its code.We need a way to store the threshold value. We don't want to write separate functions for each value, as this duplicates code. We need a first-class entity that supports the following: It can store state. It can be created at runtime. It is callable with one argument.A function may have a static local variable, but it can only store a single value at a time. Class types, on the other hand, do define first-class entities. A class-type object can store state in member variables, can be created at runtime, and can be passed between functions.GreaterN is a class that stores a threshold and is also callable with a single argument. The function-call operator must be overloaded as a member function, so it has an implicit this pointer. We have declared the this pointer as a pointer to const, since the function does not modify the GreaterN object.A GreaterN object provides the same interface as the functions required by any_of() However, it is not a function or a pointer to a function; its type is GreaterN. We need to write a new version that allows predicates of any type. Like iterators, functors are generally passed by value.The max_element() function template uses the < operator to compare elements, so it only works on types that provide that operator. It will not work with a type such as Duck that does not overload the less-than operator. We may still want to compare Ducks according to some criteria, such as by their names or their ages. We can do so by adding another parameter to represent a comparator.We can write a Duck comparator that compares two ducks by name. The code then calls the comparator with two arguments to determine if the first is less than the second. Since it doesn't require any storage, it could have been written as a function as well.Max_element() can no longer call it without a comparator argument, even for types that support the < operator. We can write a for_each() function template that implements this pattern. We return the func argument, in case it contains data that are useful to caller.Many of us encounter impostor syndrome, where we do not internalize our own accomplishments. Despite demonstrating success in a course like this, we often fear being exposed as a “fraud.” Recognizing impostors is the first step to overcoming it.Impostor syndrome differs from implicit bias in that the latter affects how we subconsciously view others, while the former affectshow we view ourselves. The result of impostor syndrome is to doubt ourselves, having feelings such as: “I was hired to fill a diversity quota”. Survey: 70 percent of people have felt like impostors for at least some part of their careers. Stop comparing ourselves to others. Join student organizations and connect with other students. Accept our accomplishments. Find a mentor.The following are additional resources on impostor syndrome.
A map is a data structure that maps keys to values. It is thus an associative data structure, since it associates a value with each key. A key feature of the standard-library map is that it is not erroneous to look up a non-existent key.A map is similar to a set in that the keys in the map are unique. Each key is associated with at most one value. However, the values themselves are not unique. We need a heterogeneous data type for the datum member of a node.We need a BinarySearchTree that can take a custom comparator, to compare key-value pairs by just the value component. We can use a pair and a BST to implement a map. We want an interface that works directly on a sequence container.The auto keyword allows the compiler to deduce the type of a sequence. If the return type of sequence.begin() is List<int>::Iterator, then the type is deduced to have type List< int>::iter. If it is a nested type, the type will be deduced as char *.The syntax of a range-based for loop is: In the example above, the variable is named item and has type int. The following loop attempts to set every element in the vector to the value 42. However, this loop does not actually modify any elements. The loop is actually modifying a copy of each element rather than an element itself.Range-based for loops are often used in combination with auto. They can be used to simplify print_all() and other for loops.The example uses range-based for loops to iterate over both the vector and the map. We declare a type-deduced reference to each element. A reference avoids making a copy, which is nontrivial for strings. The iteration over the map produces key-value pairs.
In our example, the job of read_file_contents() is to read data from a file. We have included REQUIRES clauses in many of our functions, specifying that the behavior is undefined when the requirements are violated. It is unrealistic to assume that the data will always be available and valid.Read_file_contents() should only be responsible for detecting and conveying that an error occurred. A different function further up in the call stack should do what is required to handle the error. We will look at several different strategies for doing so.Many implementations of C and C++ functions use the errno global variable to signal errors. The strategy of setting a global error code can be error-prone.C and C++ streams use the same strategy as a global variable. Return error codes are another strategy used to signal the occurrence of an error. A value from a function’s return type is reserved to indicate that the function encountered anerror.All three strategies above have the problem that the caller of a function must remember to check for an error. Neither the compiler nor the runtime detect when the caller fails to do so. Another common issue is that error checking is interleaved with the regular control flow of the caller.C++ and other modern languages use exceptions. The FactorialError class is an exception type. The standard-library stoi() function throws a std::invalid_argument object.C++ allows an object of any type to be thrown as an exception. When an exception is thrown, execution pauses and can only resume at a catch block. The code that is between the throw and the catch that handles the exception is entirely skipped.The standard-library exceptions all derive from std::exception. A user-defined exception is a class type. The constructor takes a string and stores it as a member variable.A try/catch block consists of a try block followed by one or more catch blocks. The try/ catch can only handle exceptions that occur within the try part of the block. We will shortly see how exception hierarchies interact withtry/catch blocks.C++ takes into account subtype polymorphism in matching an exception object to a catch block. If the dynamic type of the object is derived from the type of a catch parameter, the catch is able to handle that object. The body of the catch block is run.The load_roster() function is not the best place to handle an exception. The appropriate error recovery depends on the application. The caller of the function should know what to do in case of an error.Program pauses execution, then looks for an exception handler. If no matching catch is found, the function call is terminated, and the process repeats in the caller. driveThru keeps track of menu items and their prices. The get_price() member function looks up the price of an item, returning it if it is on the menu. If not, it throws an exception of type InvalidOrderException. The exception propagates outward until a viable handler is found.The exception propagates outward to main. The call to get_price() is within a try, and there is an associated catch. Execution proceeds to that catch, which prints an error message. Then execution continues after the full try/catch, ending an iteration of the loop.The email_student() function throws an EmailError if sending fails. load_roster() throws a csvstream_exception if reading the roster file fails. Finally, load_submissions() throws an exception if a submission file fails to open.We consider a few more small examples to better understand how exceptions are propagated and handled. The examples use the following exception types: GoodbyeError and HelloError. Objects of GoodbyeError will generally be thrown by a goodbye() function, while HelloError objects will be throw by hello.The program checks whether the call to goodbye() is within a try in hello. If it is, it checks whether there is a catch block that can handle a GoodbyeError. The first catch block can do so, so its code is run. This throws a HelloError, so the program checks to see if execution is in a try. It is. The remaining code in goodbye() and hello() were skipped when handling the exception.The Error class has a constructor that takes a string. The throw statement in goodbye() throws an Error object constructed with the string "bye". There is no try in goodbye(), so the program checks whether it is currently within a try in hello() Execution is indeed within the try there, and the catch block can handle the Error object.The program considers the catch blocks in order, so it is the first one that runs. Its body retrieves the message from the Error object, printing out hey. The full output is below.The code is within a try in main() so the program examines the catch blocks in order. The first cannot handle a GoodbyeError, but the second can, so the latter runs and prints unknown error. Execution continues after the try/catch, printing main returns. The full result is the following:. There are no constraints on what a C++ implementation can do if a program results in undefined behavior. For example, dereferencing a null or uninitialized pointer does not necessarily throw an exception, set a global error code, or provide any other form of error detection. It is the programmer’s responsibility to avoid undefined behavior, and there are no restrictions on what C++ can do.
The linked-list class template we defined previously creates copies of objects. A Node stores a value of type T, so a copy is made when a node is created. With this in mind, consider the following example that inserts local objects into a list. The code creates two local Llama objects and inserts them into aList. It then iterates over the list to feed each llama.The code creates Llama objects in dynamic memory and stores pointers to them in two different lists. By storing pointers in a container, we avoid making copies of the underlying objects. Containers are also useful for keeping track of multiple orderings of the same objects.The code above has a memory leak; the destructors for the lists only free the memory for the Node objects. We need to manually delete them before the lists that we are using to track them go away. This code is erroneous: it deletes each Llama object twice, resulting in undefined behavior.The llamas die automatically when the container in which they reside dies. Standard-library containers have emplace_back() functions that avoid creating temporaries. The result in memory is shown in Figure 93.We can use different comparators to maintain different orderings of the same objects. We can also keep track of polymorphic objects, meaning objects of different derived classes. This requires indirection as we saw previously. Containers of pointers enable this indirection.The Animal destructor must be declared as virtual so that dynamic binding is used to call the appropriate destructor for each object. When we are done with the objects, we need to delete them ourselves, since they are in dynamic memory.
